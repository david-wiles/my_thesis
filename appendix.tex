\chapter{Canary Source Code}
main.go
\begin{lstlisting}[style=AMMA, language=go]
/*
Copyright \copyright 2021 David Wiles <david@wiles.fyi>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package main

import "github.com/david-wiles/canary/cmd"

func main() {
	cmd.Execute()
}

\end{lstlisting}

cmd/root.go
\begin{lstlisting}[style=AMMA, language=go]
/*
Copyright \copyright 2021 David Wiles <david@wiles.fyi>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package cmd

import (
	"errors"
	"fmt"
	"github.com/david-wiles/canary/pkg"
	"github.com/spf13/cobra"
	"os"
)

var (
	autoFix bool
	dontFix bool
)

// rootCmd represents the base command when called without any subcommands
var rootCmd = &cobra.Command{
	Use:   "canary [directory]",
	Short: "Analyze security issues with a machine, system, container, or VM",
	Long: `Analyze security issues with a machine, system, container, or VM.

If you wish to automatically fix trivial issues, run the program with --fix.

It may be beneficial to combine this program with runuser. For example, if
you will be running your systems using a user called 'dummy', you can test
with this user by running:

"sudo runuser -l dummy -c 'canary' ./tests"

Each issue should reside in its own folder in the specified directory. A
file called analyze.sh will be used to examine the system, and one called solution.sh
will be used to auto-fix and issues present. If desired,an info.txt file can be
provided for information about the issue and prompt.txt file can be provided to
describe the solution.

The presence of an error will be determined by the exit status of the analyze.sh
file. If the file exits with 0, it is assumed there were no issues found, any
other status indicates an error.
`,
	Args: func(cmd *cobra.Command, args []string) error {
		if len(args) < 1 {
			return errors.New("Directory argument is required")
		} else if len(args) > 1 {
			return errors.New("Unknown arguments detected")
		}

		stat, err := os.Stat(args[0])
		if err != nil {
			if os.IsNotExist(err) {
				return errors.New("Directory not found: " + args[0])
			}
			return err
		}

		if !stat.IsDir() {
			return errors.New("Specifed path is not a directory")
		}

		return nil
	},
	Run: func(cmd *cobra.Command, args []string) {
		scanner := &pkg.CustomScanner{}

		if err := scanner.Init(args[0]); err != nil {
			panic(err)
			return
		}

		if err := scanner.Analyze(); err != nil {
			panic(err)
			return
		}

		ok, err := scanner.Fix(autoFix, dontFix)
		if err != nil {
			panic(err)
			return
		}

		if !dontFix && !ok {
			// Exit with non-zero exit code if issues remain unfixed
			os.Exit(1)
		}
	},
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}

func init() {
	rootCmd.PersistentFlags().BoolVar(&autoFix, "fix", false, "Automatically fix issues")
	rootCmd.PersistentFlags().BoolVar(&dontFix, "scan", false, "Only scan for issues")

	// Cobra also supports local flags, which will only run
	// when this action is called directly.
	rootCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")
}

\end{lstlisting}

pkg/custom.go
\begin{lstlisting}[style=AMMA, language=go]
package pkg

import (
	"encoding/json"
	"errors"
	"io/fs"
	"io/ioutil"
	"os"
	"os/exec"
	"path"
)

type CustomScanner struct {
	// IssueList contains all the issues detected by tests during the program's
	// run. It is then used to propmt the user or run solution files
	Issues IssueList

	// The path to the root directory containing test files
	dir string

	// Any steps detected in the root directory will be added to this list.
	steps []string
}

// StepConfig stores information about a test, if set. It will be used when
// writing Text to the terminal
type stepConfig struct {
	Title  string
	Text   string
	Prompt string
	Severity
}

// Init will set up all tests in the scanner. The dir argument specifies
// the root directory to search for tests and should be passed from the
// command line
func (c *CustomScanner) Init(dir string) (err error) {
	c.dir = dir
	c.steps = []string{}
	c.Issues = IssueList{}

	// Check whether the root directory is valid
	stat, err := os.Stat(dir)
	if err != nil {
		return err
	}
	if !stat.IsDir() {
		return errors.New("Specified path is not a directory")
	}

	files, err := ioutil.ReadDir(c.dir)
	if err != nil {
		return err
	}

	// Loop over directory contents and find test steps
	for _, f := range files {
		if f.IsDir() {
			// Check for analyze.sh and add to list if found
			_, err := os.Stat(path.Join(c.dir, f.Name(), "analyze.sh"))
			if err != nil {
				if !os.IsNotExist(err) {
					return err
				}
			} else {
				c.steps = append(c.steps, path.Join(c.dir, f.Name()))
			}
		}
	}

	return nil
}

// Analyze each step in the root directory and populate the IssueList
func (c *CustomScanner) Analyze() error {
	for _, step := range c.steps {
		conf, err := getStepConfig(step)
		if err != nil {
			return err
		}

		cmd := exec.Command(path.Join(step, "analyze.sh"))
		if err := cmd.Run(); err != nil {
			// Check why err is nil. If not due to non-zero exit code, alert the user
			if errors.Is(err, &fs.PathError{}) {
				println("Could not execute the file. Make sure all permissions are set correctly for the current user")
			} else {
				// Look for Text files in step and copy to issue if found.
				issueText, err := getFileText(conf.Text, path.Join(step, "info.txt"))
				if err != nil {
					return err
				}

				solutionText, err := getFileText(conf.Prompt, path.Join(step, "prompt.txt"))
				if err != nil {
					return err
				}

				// TODO custom severity levels
				c.Issues = append(c.Issues, NewIssue(conf.Severity, conf.Title, issueText).
					WithSolution(solutionText, customSolution(path.Join(step, "solution.sh"))))
			}
		}
	}
	return nil
}

// Fix the issues found by a scan. Analyze() must be called first to build the IssueList
func (c *CustomScanner) Fix(autoFix, dontFix bool) (bool, error) {
	if len(c.Issues) > 0 {
		c.Issues.PrintIssues("Issues Detected")
		return c.Issues.Fix(autoFix, dontFix)
	}

	c.Issues.PrintIssues("No Issues Detected")
	return true, nil
}

// Read the step's config file if it exists. Otherwise, default settings are used
func getStepConfig(step string) (*stepConfig, error) {
	conf := &stepConfig{
		path.Base(step),
		path.Base(step),
		path.Base(step),
		SeverityCritical,
	}

	// Read configuration file for the step if it exists
	stat, err := os.Stat(path.Join(step, "conf.json"))
	if err != nil {
		if !os.IsNotExist(err) {
			return nil, err
		}
	} else if !stat.IsDir() {
		f, err := os.Open(path.Join(step, "conf.json"))
		if err != nil {
			return nil, err
		}
		decoder := json.NewDecoder(f)
		if err := decoder.Decode(conf); err != nil {
			return nil, err
		}
	}
	return conf, nil
}

// Get a file's Text or use the default string given
func getFileText(defaultText, filepath string) (string, error) {
	_, err := os.Stat(filepath)
	if err != nil {
		if os.IsNotExist(err) {
			return defaultText, nil
		}
		return "", err
	}

	issueTextBytes, err := ioutil.ReadFile(filepath)
	if err != nil {
		return "", err
	}

	return string(issueTextBytes), nil
}

// Create a solution function using a script file with the given path
func customSolution(path string) func() error {
	return func() error {
		cmd := exec.Command(path)
		if err := cmd.Run(); err != nil {
			return err
		}
		return nil
	}
}

\end{lstlisting}

pkg/issue.go
\begin{lstlisting}[style=AMMA, language=go]
package pkg

import (
	"fmt"
	"github.com/fatih/color"
	"strings"
)

type Severity int

var (
	SeverityMinor    Severity = 3
	SeverityWarning  Severity = 2
	SeveritySerious  Severity = 1
	SeverityCritical Severity = 0
)

type Issue struct {
	// If solution is not nil, then it can be fixed programmatically. Many issues
	// will not have a solution and will not have the option to be fixed this way
	Solution func() error

	// Severity level determines messaging as well as the possibility of a fix
	severity Severity

	// Title given to the issue for representation in a list
	title string

	// Message to print to the terminal when PrintIssues is called. Explains the
	// issue and its severity. messageStyle is used to render the issue
	message string

	// If the issue has a programmatic solution, the user will be prompted to fix
	// it with the string stored in prompt. promptStyle will be used to render
	prompt string
}

type IssueList []*Issue

// PrintIssues will iterate over an IssueList and call each Issue's Render() and
// RenderTitle functions. These will be printed directly to the terminal instead
// of being returned as a string
func (list IssueList) PrintIssues(header string) {
	color.White(header)
	for _, issue := range list {
		issue.RenderTitle()
	}
	color.White("\n")
}

// Fix will fix all issues in an IssueList as long as autofix is true
// and a solution exists. If there is not a solution, then the user
// is simply prompted with directions to fix the issue
func (list IssueList) Fix(autoFix, dontFix bool) (bool, error) {
	resolved := true

	for _, issue := range list {
		if issue.Solution != nil && !dontFix {
			if autoFix {
				if err := issue.Solution(); err != nil {
					return false, err
				}
			} else {
				ok, err := issue.PromptFix()
				if err != nil {
					return false, err
				}
				if !ok {
					resolved = false
				}
			}
		} else {
			resolved = false
		}
	}
	return resolved, nil
}

// RenderInfo will print the issue's info string
func (issue Issue) RenderInfo() {
	color.White(issue.message)
}

// RenderTitle will print the issue's title
func (issue Issue) RenderTitle() {
	switch issue.severity {
	case SeverityCritical:
		color.HiMagenta(issue.title)
	case SeveritySerious:
		color.Red(issue.title)
	case SeverityWarning:
		color.Yellow(issue.title)
	case SeverityMinor:
		color.White(issue.title)
	}
}

// Prompts the user to fix the issue and calls the solution function if they choose
// to fix it. If there is no programmatic solution, a prompt may still be printed
// but a user input will not be anticipated
func (issue Issue) PromptFix() (bool, error) {

	if len(issue.prompt) == 0 {
		return false, nil
	}

	if issue.Solution != nil {
		color.White(issue.prompt + "\n" + "Do you wish to fix these Issues? [Y/n]")

		var input string
		_, err := fmt.Scanln(&input)
		if err != nil {
			if err.Error() == "unexpected newline" {
				input = ""
			} else {
				return false, err
			}
		}

		// If the user does not enter n or N, fix this issue
		if strings.ToLower(input) != "n" {
			if err := issue.Solution(); err != nil {
				return false, err
			}
			return true, nil
		}

	} else {

		color.White(issue.prompt + "\n" + "(This issue must be fixed manually)")
		return false, nil
	}

	return false, nil
}

// MinorIssue will generate an Issue with minor severity
func MinorIssue(title, message string) *Issue {
	return &Issue{
		severity: SeverityMinor,
		message:  message,
		title:    title,
	}
}

// WarningIssue will generate an Issue with warning severity
func WarningIssue(title, message string) *Issue {
	return &Issue{
		severity: SeverityWarning,
		message:  message,
		title:    title,
	}
}

// SevereIssue will generate an Issue with severe severity
func SevereIssue(title, message string) *Issue {
	return &Issue{
		severity: SeveritySerious,
		message:  message,
		title:    title,
	}
}

// CriticalIssue will generate an Issue with critical severity
func CriticalIssue(title, message string) *Issue {
	return &Issue{
		severity: SeverityCritical,
		message:  message,
		title:    title,
	}
}

// NewIssue is a factory function which will create an issue with the specified severity
func NewIssue(severity Severity, title, message string) *Issue {
	switch severity {
	case SeverityCritical:
		return CriticalIssue(title, message)
	case SeveritySerious:
		return SevereIssue(title, message)
	case SeverityWarning:
		return WarningIssue(title, message)
	default:
		return MinorIssue(title, message)
	}
}

// WithSolution will add the given solution and message to an Issue
func (issue *Issue) WithSolution(prompt string, solution func() error) *Issue {
	issue.prompt = issue.message + "\n" + prompt
	issue.Solution = solution
	return issue
}

\end{lstlisting}

\chapter{Docker Vagrantfile}

The Docker Vagrantfile creates a VM with Docker installed using the instructions from the Docker documentation.
This configuration is the basis for all scripts used in this work.

\begin{lstlisting}[style=AMMA, language=ruby]
# -*- mode: ruby -*-
# vi: set ft=ruby :

$install = <<-'SCRIPT'
sudo apt-get update
sudo apt-get -y install \
    ca-certificates \
    curl \
    gnupg \
    lsb-release
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt-get update
sudo apt-get -y install docker-ce docker-ce-cli containerd.io
SCRIPT

Vagrant.configure("2") do |config|
  config.vm.box = "bento/ubuntu-20.04"
  config.vm.boot_timeout = 600 # My computer is slow
  config.vm.provision "shell", inline: $install
end

\end{lstlisting}

\chapter{Firecracker Setup}

Firecracker is the VMM behind AWS Lambda. It uses KVM with a stripped-down frontend to reduce the attack surface.
The project is open-source and can be run on any machine with a recent CPU.

First, clone firecracker and build from source, or install a pre-built binary. From https://github.com/firecracker-microvm/firecracker/blob/main/docs/getting-started.md:
\begin{lstlisting}[style=AMMA, language=bash]
release_url="https://github.com/firecracker-microvm/firecracker/releases"
latest=$(basename $(curl -fsSLI -o /dev/null -w  %{url_effective} ${release_url}/latest))
arch=`uname -m`
curl -L ${release_url}/download/${latest}/firecracker-${latest}-${arch}.tgz \
| tar -xz
mv firecracker-${latest}-$(uname -m) firecracker
arch=`uname -m`
dest_kernel="hello-vmlinux.bin"
dest_rootfs="hello-rootfs.ext4"
image_bucket_url="https://s3.amazonaws.com/spec.ccfc.min/img/quickstart_guide/$arch"

if [ ${arch} = "x86_64" ]; then
    kernel="${image_bucket_url}/kernels/vmlinux.bin"
    rootfs="${image_bucket_url}/rootfs/bionic.rootfs.ext4"
elif [ ${arch} = "aarch64" ]; then
    kernel="${image_bucket_url}/kernels/vmlinux.bin"
    rootfs="${image_bucket_url}/rootfs/bionic.rootfs.ext4"
else
    echo "Cannot run firecracker on $arch architecture!"
    exit 1
fi

echo "Downloading $kernel..."
curl -fsSL -o $dest_kernel $kernel

echo "Downloading $rootfs..."
curl -fsSL -o $dest_rootfs $rootfs

echo "Saved kernel file to $dest_kernel and root block device to $dest_rootfs."
arch=`uname -m`
kernel_path=$(pwd)"/hello-vmlinux.bin"

if [ ${arch} = "x86_64" ]; then
    curl --unix-socket /tmp/firecracker.socket -i \
      -X PUT 'http://localhost/boot-source'   \
      -H 'Accept: application/json'           \
      -H 'Content-Type: application/json'     \
      -d "{
            \"kernel_image_path\": \"${kernel_path}\",
            \"boot_args\": \"console=ttyS0 reboot=k panic=1 pci=off\"
       }"
elif [ ${arch} = "aarch64" ]; then
    curl --unix-socket /tmp/firecracker.socket -i \
      -X PUT 'http://localhost/boot-source'   \
      -H 'Accept: application/json'           \
      -H 'Content-Type: application/json'     \
      -d "{
            \"kernel_image_path\": \"${kernel_path}\",
            \"boot_args\": \"keep_bootcon console=ttyS0 reboot=k panic=1 pci=off\"
       }"
else
    echo "Cannot run firecracker on $arch architecture!"
    exit 1
fi
rootfs_path=$(pwd)"/hello-rootfs.ext4"
curl --unix-socket /tmp/firecracker.socket -i \
  -X PUT 'http://localhost/drives/rootfs' \
  -H 'Accept: application/json'           \
  -H 'Content-Type: application/json'     \
  -d "{
        \"drive_id\": \"rootfs\",
        \"path_on_host\": \"${rootfs_path}\",
        \"is_root_device\": true,
        \"is_read_only\": false
   }"
curl --unix-socket /tmp/firecracker.socket -i \
  -X PUT 'http://localhost/actions'       \
  -H  'Accept: application/json'          \
  -H  'Content-Type: application/json'    \
  -d '{
      "action_type": "InstanceStart"
   }'
\end{lstlisting}

Alternatively, you can build your own file system images and start the VM from a config file instead of using the API.

To create a file system image based on alpine linux:
\begin{lstlisting}[style=AMMA, language=bash]
# Instructions to create a rootfs image from https://github.com/firecracker-microvm/firecracker/blob/main/docs/rootfs-and-kernel-setup.md
dd if=/dev/zero of=rootfs.ext4 bs=1048576 count=50
mkfs.ext4 rootfs.ext4
mkdir /tmp/my-rootfs
sudo mount rootfs.ext4 /tmp/my-rootfs
sudo docker run -it --rm -v /tmp/my-rootfs:/my-rootfs alpine

# Inside container
apk add openrc
apk add util-linux

# Set up a login terminal on the serial console (ttyS0):
ln -s agetty /etc/init.d/agetty.ttyS0
echo ttyS0 > /etc/securetty
rc-update add agetty.ttyS0 default

# Make sure special file systems are mounted on boot:
rc-update add devfs boot
rc-update add procfs boot
rc-update add sysfs boot

# Then, copy the newly configured system to the rootfs image:
for d in bin etc lib root sbin usr; do tar c "/$d" | tar x -C /my-rootfs; done

# The above command may trigger the following message:
# tar: Removing leading "/" from member names
# However, this is just a warning, so you should be able to
# proceed with the setup process.

for dir in dev proc run sys var; do mkdir /my-rootfs/${dir}; done

# All done, exit docker shell.
exit

sudo umount /tmp/my-rootfs
\end{lstlisting}

Then, start the VM. This assumes you have firecracker in your PATH.
\begin{lstlisting}[style=AMMA, language=bash]
set -eu

# download a kernel
[ -e ./vmlinux.bin ] || wget -q https://s3.amazonaws.com/spec.ccfc.min/img/quickstart_guide/x86_64/kernels/vmlinux.bin

TAP_DEV="fc-88-tap0"

# set up the kernel boot args
MASK_LONG="255.255.255.252"
MASK_SHORT="/30"
FC_IP="169.254.0.21"
TAP_IP="169.254.0.22"
FC_MAC="02:FC:00:00:00:05"

KERNEL_BOOT_ARGS="ro console=ttyS0 noapic reboot=k panic=1 pci=off nomodules random.trust_cpu=on"
KERNEL_BOOT_ARGS="${KERNEL_BOOT_ARGS} ip=${FC_IP}::${TAP_IP}:${MASK_LONG}::eth0:off"

# make a configuration file
cat <<EOF > ./vmconfig.json
{
  "boot-source": {
    "kernel_image_path": "./vmlinux.bin",
    "boot_args": "$KERNEL_BOOT_ARGS"
  },
  "drives": [
    {
      "drive_id": "rootfs",
      "path_on_host": "./rootfs.ext4",
      "is_root_device": true,
      "is_read_only": false
    }
  ],
  "machine-config": {
    "vcpu_count": 2,
    "mem_size_mib": 1024
  }
}
EOF
# start firecracker
sudo firecracker --no-api --config-file ./vmconfig.json
\end{lstlisting}

This just starts a VM, to interact with it you will need to attach a network interface to the vmconfig.json to send
HTTP requests or connect via SSH.

