\chapter{Canary Source Code}

The source code for Canary. The full repository including install script can be found at github.com/david-wiles/canary-scala.

\medskip

ArgParse.scala
\begin{lstlisting}[style=AMMA, language=Scala]
import java.nio.file.Paths

/**
 * ArgParse provides a way to specify commands and arguments for Canary without any
 * extra third party packages. Parsing is simple and only full flags are supported.
 * https://stackoverflow.com/questions/2315912/best-way-to-parse-command-line-parameters
 */
class ArgParse {
  val usage: String =
    """
      |Usage: canary [OPTIONS] [COMMAND]
      |
      |A general-purpose security scanner and resolver
      |
      |Options:
      |    --local Path to local canary packages. Default location is ~/.canary
      |
      |Commands:
      |    install  Installs new packages from the list provided
      |    upgrade  Upgrades packages from the list provided
      |    check    Checks security issues using the given packages
      |
      |Run 'canary COMMAND --help' to view more information about a command
      |""".stripMargin

  private val repo: String = "https://canary.wiles.fyi"
  private var local: String = Paths.get(System.getProperty("user.home"), ".canary").toString

  def parse(args: List[String]): Option[Command] = {
    if (args.isEmpty) Option(HelpCommand(usage))
    else {
      args match {
        case Nil => Option(InvalidCommand(usage))
        case "install" :: "--help" :: tail => Option(HelpCommand(InstallCommand.usage))
        case "install" :: tail => parseInstallArgs(tail)
        case "upgrade" :: "--help" :: tail => Option(HelpCommand(UpgradeCommand.usage))
        case "upgrade" :: tail => parseUpgradeArgs(tail)
        case "check" :: "--help" :: tail => Option(HelpCommand(CheckCommand.usage))
        case "check" :: tail => parseCheckArgs(tail)
        case "remove" :: "--help" :: tail => Option(HelpCommand(RemoveCommand.usage))
        case "remove" :: tail => parseRemoveArgs(tail)
        case "--help" :: tail => Option(HelpCommand(usage))
        case string :: tail => Option(InvalidCommand("Invalid command provided: " + string))
      }
    }
  }

  /**
   * Parse args used by all commands
   *
   * @param switch the flag found
   * @param list   the rest of the command line arguments
   * @param next   function to call for the next step in parsing flags
   * @return
   */
  private def parsePersistentArgs(switch: String, list: List[String], next: List[String] => Option[Command]): Option[Command] = {
    switch match {
      case "--local" =>
        if (list.nonEmpty) {
          local = list.head
          next(list.tail)
        } else {
          Option(InvalidCommand("Missing local directory associated with --local"))
        }
      case _ => Option(InvalidCommand("Invalid option provided: " + switch))
    }
  }

  /**
   * Parse flags used by the install command
   *
   * @param args command line arguments
   * @return
   */
  private def parseInstallArgs(args: List[String]): Option[Command] = {
    var packages: List[String] = List()
    var urlString = repo

    def _parse(args: List[String]): Option[Command] = {
      args match {
        case Nil =>
          if (packages.nonEmpty) {
            Option(InstallCommand(packages, urlString, local))
          } else {
            Option(InvalidCommand("Must provide a package to install" + sys.props("line.separator") + InstallCommand.usage))
          }
        case "--repo" :: url :: tail =>
          urlString = url
          _parse(tail)
        case string :: tail =>
          if (string(0) == '-') {
            parsePersistentArgs(string, tail, _parse)
          } else {
            packages = string :: packages
            _parse(tail)
          }
      }
    }

    _parse(args)
  }

  /**
   * Parse flags used by the upgrade command
   *
   * @param args command line arguments
   * @return
   */
  private def parseUpgradeArgs(args: List[String]): Option[Command] = {
    var packages: List[String] = List()
    var urlString = repo

    def _parse(args: List[String]): Option[Command] = {
      args match {
        case Nil =>
          if (packages.nonEmpty) {
            Option(UpgradeCommand(packages, urlString, local))
          } else {
            Option(InvalidCommand("Must provide a package to upgrade" + sys.props("line.separator") + UpgradeCommand.usage))
          }
        case "--repo" :: url :: tail =>
          urlString = url
          _parse(tail)
        case string :: tail =>
          if (string(0) == '-') {
            parsePersistentArgs(string, tail, _parse)
          } else {
            packages = string :: packages
            _parse(tail)
          }
      }
    }

    _parse(args)
  }

  /**
   * Parse flags used by the check command
   *
   * @param args command line arguments
   * @return
   */
  private def parseCheckArgs(args: List[String]): Option[Command] = {
    var packages: List[String] = List()
    var dir: Option[String] = None
    var autoFix = false
    var scanOnly = false

    def _parse(args: List[String]): Option[Command] = {
      args match {
        case Nil =>
          if (packages.isEmpty && dir.isEmpty) {
            Option(InvalidCommand("Must provide one of packages or directory" + sys.props("line.separator") + CheckCommand.usage))
          } else {
            Option(CheckCommand(packages, dir, local, autoFix, scanOnly))
          }
        case "--scan-only" :: tail =>
          scanOnly = true
          _parse(tail)
        case "--auto-fix" :: tail =>
          autoFix = true
          _parse(tail)
        case "--directory" :: path :: tail =>
          dir = Some(path)
          _parse(tail)
        case string :: tail =>
          if (string(0) == '-') {
            parsePersistentArgs(string, tail, _parse)
          } else {
            packages = string :: packages
            _parse(tail)
          }
      }
    }

    _parse(args)
  }

  /**
   * Parse arguments to remove packages
   * @param args command line arguments
   * @return either a RemoveCommand, InvalidCommand, or HelpCommand
   */
  private def parseRemoveArgs(args: List[String]): Option[Command] = {
    var packages: List[String] = List()

    def _parse(args: List[String]): Option[Command] = {
      args match {
        case Nil =>
          if (packages.isEmpty)
            Option(InvalidCommand("Must provide a package to remove" + sys.props("line.separator") + RemoveCommand.usage))
          else
            Option(RemoveCommand(local, packages))
        case string :: tail =>
          if (string(0) == '-') {
            parsePersistentArgs(string, tail, _parse)
          } else {
            packages = string :: packages
            _parse(tail)
          }
      }
    }

    _parse(args)
  }
}

\end{lstlisting}

Canary.scala
\begin{lstlisting}[style=AMMA, language=Scala]
import scala.sys.exit

object Canary {
  /**
   * Used whenever a fatal error occurs and the program should exit immediately.
   * @param message message to print prior to exit
   * @return nothing
   */
  def fatal(message: String): Nothing = {
    println(message)
    exit(1)
  }

  /**
   * Entrypoint for canary
   * @param args command line arguments
   */
  def main(args: Array[String]): Unit = {
    (new ArgParse).parse(args.toList)
      .getOrElse(InvalidCommand("Something went wrong. Please contact the maintainers of canary and include steps to replicate the issue"))
      .run()
  }
}

\end{lstlisting}

CanaryRepository.scala
\begin{lstlisting}[style=AMMA, language=Scala]
import org.apache.commons.compress.archivers.tar.{TarArchiveEntry, TarArchiveInputStream}
import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream
import org.apache.commons.compress.utils.IOUtils
import sttp.client3._

import java.io.{BufferedInputStream, File, FileInputStream, FileOutputStream}
import java.nio.file.{Files, Path, Paths}
import java.security.MessageDigest
import scala.io.Source

/**
 * CanaryRepository stores state and methods required to download and update
 * canary packages
 *
 * @param domain    url for the remote canary repository
 * @param localRoot local canary root
 */
class CanaryRepository(domain: String, localRoot: String) {

  private val backend = HttpURLConnectionBackend()

  /**
   * Checks whether the specified package exists in the repository
   *
   * @param name name of the package. This should correspond to a tarball in the local directory
   * @return true if package exists, false if not
   */
  def hasPackage(name: String, version: String): Boolean = {
    if (version == "latest") {
      getLatestVersionString(name) match {
        case None => false
        case Some(version) => Files.exists(Paths.get(localRoot, name, version))
      }
    } else {
      Files.exists(Paths.get(localRoot, name, version))
    }
  }

  /**
   * Verify the downloaded checksum against the tarball
   *
   * @param tarball  the tarball file
   * @param checksum the checksum file
   * @return true if checksum matches, false if not
   */
  def verifyPackage(tarball: File, checksum: File): Boolean = {
    if (!tarball.exists() || !checksum.exists()) {
      false
    } else {
      val digest = MessageDigest.getInstance("SHA-256")
        .digest(Files.readAllBytes(tarball.toPath))

      val hashBuilder = new StringBuilder()
      for (i <- 0 until digest.length) {
        hashBuilder.append(Integer.toString((digest(i) & 0xff) + 0x100, 16).substring(1))
      }

      val sumSource = Source.fromFile(checksum)
      val sum = (try sumSource.mkString finally sumSource.close()).split("\\s")

      if (sum.nonEmpty) {
        sum(0).equals(hashBuilder.toString())
      } else {
        false
      }
    }
  }

  /**
   * Get latest version of the specified package
   *
   * @param name The package to update
   */
  def updatePackage(name: String): Unit = {
    getLatestVersionString(name) match {
      case None => println(s"Could not update package $name: could not determine latest version")
      case Some(version) =>
        if (hasPackage(name, version)) {
          println(s"Updating $name...")
          downloadPackage(name, version)
        } else {
          println(s"A package named $name could not be found. Please use 'canary install $name' instead.")
        }
    }
  }

  /**
   * Get a string representing the latest version for the specified package. The latest version
   * is stored in a file called version.txt in the package's directory on the remote server.
   *
   * @param name The name of the package
   * @return String representing the version, e.g. 1.0.2
   */
  def getLatestVersionString(name: String): Option[String] = {
    val resp = basicRequest
      .response(asString)
      .get(uri"$domain/$name/version.txt")
      .send(backend)

    resp.body match {
      case Left(err) => None
      case Right(version) => Some(version)
    }
  }

  /**
   * Download the specified version of a package. If no version is specified, the latest will
   * automatically be downloaded along with the checksum for the package
   *
   * @param name    name of the package to download
   * @param version version to get. Default "latest"
   * @return error message if the package could not be downloaded or verified
   */
  def downloadPackage(name: String, version: String): Unit = {
    val pkgFilename: String = if (version.equals("latest")) {
      getLatestVersionString(name) match {
        case None =>
          println(s"Unable to determine latest version for package $name. Skipping package...")
          return
        case Some(version) => s"${name}_$version.tar.gz"
      }
    } else {
      s"${name}_$version.tar.gz"
    }

    basicRequest
      .response(asFile(new File(Paths.get(localRoot, pkgFilename).toString)))
      .get(uri"$domain/$name/$pkgFilename")
      .send(backend)
      .body match {
      case Left(err) => println("Could not download package: " + err)
      case Right(tar) =>
        println("Successfully downloaded package!")

        // Verify checksum
        basicRequest
          .response(asFile(new File(Paths.get(localRoot, s"$pkgFilename.sum").toString)))
          .get(uri"$domain/$name/$pkgFilename.sum")
          .send(backend)
          .body match {
          case Left(err) => println("Could not download checksum to verify package: " + err)
          case Right(sum) =>
            println("Successfully downloaded checksum!")

            if (!verifyPackage(tar, sum)) {
              println(s"Checksum verification unsuccessful. Try downloading the package and verifying manually from $domain")
            } else {
              println("Checksum verification successful.")
              println(untarPackage(localRoot, tar)
                .getOrElse("Successfully extracted package into " + localRoot))
            }

            // Clean up files
            tar.delete()
            sum.delete()
            println("Deleted archive files.")
        }
    }
  }

  /**
   * Extract a downloaded package tarball into the proper folder in the same directory. If the name of
   * the tarball is pkg_2.1.1.tar.gz, the files will be extracted into pkg/2.1.1/...
   *
   * @param root the canary package root
   * @param file the tarball
   * @return if any exceptions are caught, they will be returned as a string
   */
  def untarPackage(root: String, file: File): Option[String] = {
    try {
      val inputStream = new TarArchiveInputStream(
        new GzipCompressorInputStream(
          new BufferedInputStream(
            new FileInputStream(
              file
            )
          )
        )
      )
      var entry: TarArchiveEntry = inputStream.getNextTarEntry
      while (entry != null) {
        val outputPath = Paths.get(root, entry.getName)
        if (entry.isDirectory) {
          Files.createDirectories(outputPath)
        } else {
          Files.createDirectories(outputPath.getParent)
          IOUtils.copy(inputStream, new FileOutputStream(outputPath.toFile))
        }

        entry = inputStream.getNextTarEntry
      }

      inputStream.close()

      None
    } catch {
      case e: Throwable => Some(e.getMessage)
    }
  }
}
\end{lstlisting}

CheckCommand.scala
\begin{lstlisting}[style=AMMA, language=Scala]
import Canary.fatal

import scala.collection.mutable.ListBuffer

/**
 * CheckCommand gathers canary tasks and executes them
 * @param packages  canary packages to analyze
 * @param directory directory to analyze. Optional
 * @param localPath local canary root
 * @param autoFix   indicates issues found by tasks should be fixed without a prompt
 * @param scanOnly  indicates that the user should not be prompted to fix issues. Overrides autoFix
 */
case class CheckCommand(packages: List[String],
                        directory: Option[String],
                        localPath: String,
                        autoFix: Boolean,
                        scanOnly: Boolean) extends Command {

  override def run(): Unit = {
    val tasks: ListBuffer[Task] = ListBuffer()

    if (packages.isEmpty && directory.isEmpty)
      fatal("Must provide one of directory or packages")

    // Gather all tasks from the directory if one was specified
    if (directory.nonEmpty) {
      val dir = directory.get
      tasks.addAll(
        TaskBuilder.fromDir(dir)
          .getOrElse({
            fatal("Fatal: " + dir + " is not a directory.")
          })
      )
    }

    // Iterate over package list and add all tasks from the package
    for (packageName <- packages) {
      tasks.addAll(
        TaskBuilder.fromPackage(localPath, packageName)
          .getOrElse({
            fatal("Fatal: " + packageName + " was not found. Please check your package install location or install it with 'canary install " + packageName + "'")
          })
      )
    }

    // Analyze each issue and fix
    for (task <- tasks) {
      task.doTask(autoFix, scanOnly)
    }
  }
}

object CheckCommand {
  val usage: String =
    """
      |Usage: canary check [OPTIONS] [PACKAGES...]
      |
      |Checks the system against rules defined in the specified packages
      |
      |Options:
      |    --directory Custom package to use to scan system
      |    --auto-fix  Fix issues found without prompting
      |    --scan-only Scan for issues only and don't prompt to fix
      |""".stripMargin
}

\end{lstlisting}

Command.scala
\begin{lstlisting}[style=AMMA, language=Scala]
/**
 * A Command is any action that can be run by canary. It has an associated action which
 * should be initiated by the run() method.
 */
trait Command {
  def run(): Unit
}

case class HelpCommand(output: String) extends Command {
  override def run(): Unit = println(output)
}

case class InvalidCommand(message: String) extends Command {
  override def run(): Unit = Canary.fatal(message)
}

\end{lstlisting}

InstallCommand.scala
\begin{lstlisting}[style=AMMA, language=Scala]
import java.nio.file.{Files, Paths}

/**
 * InstallCommand is used to install packages to the local canary root
 * @param packages  list of packages to install
 * @param domain       url of remote canary repository
 * @param localPath path to local canary root
 */
case class InstallCommand(packages: List[String], domain: String, localPath: String) extends Command {
  override def run(): Unit = {
    // Ensure canary root exists
    if (!Files.exists(Paths.get(localPath)))
      Files.createDirectories(Paths.get(localPath))

    // Download packages
    val repo = new CanaryRepository(domain, localPath)
    for (name <- packages) {
      name.split('@') match {
        case Array(pkg, version) => repo.downloadPackage(pkg, version)
        case Array(pkg) => repo.downloadPackage(pkg, "latest")
      }
    }
  }
}

object InstallCommand {
  val usage: String =
    """
      |Usage: canary install [OPTIONS] [PACKAGES...]
      |
      |Installs packages to the local system from a remote repository
      |
      |Options:
      |    --repo URL for the repository to pull from
      |""".stripMargin
}

\end{lstlisting}

RemoveCommand.scala
\begin{lstlisting}[style=AMMA, language=Scala]
import java.io.File
import java.nio.file.Paths

case class RemoveCommand(packageRoot: String, packages: List[String]) extends Command {
  override def run(): Unit = {
    // Delete the file or directory recursively
    def deleteRecursively(result: Boolean, file: File): Boolean = {
      if (!file.isDirectory)
        !(file.exists && !file.delete) && result
      else
        file.listFiles.foldLeft(result)(deleteRecursively) && file.delete()
    }

    for (pkg <- packages) {
      val pkgPath = pkg.split("@") match {
        case Array(name, version) => Paths.get(packageRoot, name, version)
        case Array(name) => Paths.get(packageRoot, name)
      }

      if (deleteRecursively(result = true, new File(pkgPath.toString)))
        println(s"Removed package $pkg")
      else
        println(s"Unable to remove package $pkg")
    }
  }
}

object RemoveCommand {
  val usage: String =
    """
      |Usage: canary remove [OPTIONS] [PACKAGES...]
      |
      |Removes packages from the local system
      |
      |""".stripMargin
}

\end{lstlisting}

Task.scala
\begin{lstlisting}[style=AMMA, language=Scala]
import java.nio.file.{Files, Paths}
import scala.io.Source
import scala.io.StdIn.readLine

/**
 * A Task is a single action that canary should perform during the CheckCommand run.
 * This action should at least provide a way to scan the system for some issue and
 * include a description of the issue. It may also optionally provide a way to fix
 * the issue programmatically.
 *
 * These are built from canary packages and are specified by a config file in
 * each child directory of the package. The config file can contain:
 *
 * "analyze": the path to the shell file to run to analyze the issue the task describes
 * "solution": path to the shell file to fix the issue if it exists
 * "description": a string describing the task
 */
trait Task {
  def doTask(autoFix: Boolean, skipFix: Boolean): Unit
}

object Task {
  /**
   * Create a task from the files in the directory at location
   *
   * @param location a directory inside a canary package
   * @return
   */
  def create(location: String): Task = {
    val configPath = Paths.get(location, "config")
    if (Files.exists(configPath)) {
      new ScriptTask(location)
    } else {
      EmptyTask(location)
    }
  }
}

/**
 * A properly formatted task will be created as a ScriptTask, which includes scripts to run
 * to analyze and fix issues
 *
 * @param location the filename of the task's directory
 */
class ScriptTask(location: String) extends Task {
  private var analyzeFilename: Option[String] = None
  private var solutionFilename: Option[String] = None
  private var description: String = location

  private val source = Source.fromFile(Paths.get(location, "config").toFile)
  for (line <- source.getLines())
    line.split("=", 2) match {
      case Array("analyze", value) => analyzeFilename = Some(value)
      case Array("solution", value) => solutionFilename = Some(value)
      case Array("description", value) => description = value
    }
  source.close()


  def doTask(autoFix: Boolean, skipFix: Boolean): Unit = {
    if (analyzeFilename.isEmpty) {
      println(s"Cannot perform task $location: analyze file is not specified. Skipping...")
      return
    }

    val analyzeProcess = new ProcessBuilder(Paths.get(location, analyzeFilename.get).toString)
      .start()

    if (analyzeProcess.waitFor() != 0) {
      println(Console.RED + "[FAIL] " + Console.WHITE + description)

      // Check if all conditions are met before running the solution file. The command must:
      // 1: not be run with --scan-only
      // 2: contain an executable file called solution.sh
      // 3: either be used with --auto-fix or user answered yes on prompt
      if (!skipFix && solutionFilename.isDefined && (autoFix || promptFix())) {
        println("Attempting to fix issue...")
        val fixProcess = new ProcessBuilder(Paths.get(location, solutionFilename.get).toString)
          .start()
        if (fixProcess.waitFor() != 0) {
          println(Console.MAGENTA + "Solution file exited with non-zero status. You may need to fix this issue another way." + Console.WHITE)
        } else {
          println("Solution file exited successfully. You may want to run canary again to verify the fix.")
        }
      }
    } else {
      println(Console.GREEN + "[PASS] " + Console.WHITE + description)
    }
  }

  private def promptFix(): Boolean = {
    while (true) {
      // Prompt user until they enter a y or n
      println("Attempt to fix this issue? [y/n]")
      val input = readLine()
      if (input.nonEmpty) {
        if (input.equals("n") || input.equals("N")) {
          return false
        } else if (input.equals("y") || input.equals("Y")) {
          return true
        }
      }
    }
    false
  }
}

// A task will require at minimum an analyze file and a description. If these can't be resolved then
// an empty task is created to alert the user that the task is invalid and will not run.
case class EmptyTask(location: String) extends Task {
  override def doTask(autoFix: Boolean, skipFix: Boolean): Unit = {
    println(
      s"""
         |Unable to initialize task at $location. If this is a package, please contact the package's maintainers.
         |If this is a custom scan, make sure an analyze.sh and description.txt file exist in the directory for this task.
         |""".stripMargin)
  }
}
\end{lstlisting}

TaskBuilder.scala
\begin{lstlisting}[style=AMMA, language=Scala]
import java.io.File
import java.nio.file.{Files, Paths}
import scala.collection.mutable.ListBuffer

/**
 * TaskBuilder provides methods to create lists of tasks for Canary from a directory or package
 */
object TaskBuilder {
  /**
   * Creates a ListBuffer containing tasks using the given directory
   *
   * @param dir path to the directory
   * @return the tasks contained in the specified directory
   */
  def fromDir(dir: String): Option[ListBuffer[Task]] = {
    val directory = new File(dir)
    if (directory.exists && directory.isDirectory) {
      val tasks: ListBuffer[Task] = ListBuffer()
      for (file <- directory.listFiles if file.isDirectory) {
        tasks += Task.create(file.getAbsolutePath)
      }
      Some(tasks)
    } else {
      None
    }
  }

  /**
   * Creates a buffer of tasks from a package name. If no version is specified, then the
   * latest is used. The packages are stored in the canary directory in two levels: the
   * first level is the name of the package, and the second level is the version of the
   * package. By listing the packages in the second directory and choosing the version
   * with the highest number we use the latest package
   *
   * @param root    the canary package sources root
   * @param pkgName name of the package to gather tasks from, formatted as pkg@version
   * @return list of the tasks contained in the package
   */
  def fromPackage(root: String, pkgName: String): Option[ListBuffer[Task]] = {
    val pkgDir = pkgName.split('@') match {
      case Array(name, version) => Paths.get(root, name, version)
      case Array(name) =>
        if (Files.exists(Paths.get(root, name))) {
          val version = latestInstalledVersion(new File(Paths.get(root, name).toString).listFiles.map(f => f.getName))
          Paths.get(root, name, version)
        } else {
          Paths.get(root, name)
        }
    }
    fromDir(pkgDir.toString)
  }

  /**
   * Get the latest version number from a list of version numbers
   *
   * @param versions the list of version numbers
   * @return string representing latest package version
   */
  def latestInstalledVersion(versions: Array[String]): String = {
    var latest = Array(0, 0, 0)
    for (version <- versions) {
      version.split('.') match {
        case Array(major, minor, update) =>
          if (major.toInt > latest(0) ||
            major.toInt == latest(0) && minor.toInt > latest(1) ||
            major.toInt == latest(0) && minor.toInt == latest(1) && update.toInt > latest(2)) {
            latest = Array(major.toInt, minor.toInt, update.toInt)
          }
        case Array(major, minor) =>
          if (major.toInt > latest(0) ||
            major.toInt == latest(0) && minor.toInt > latest(1)) {
            latest = Array(major.toInt, minor.toInt, 0)
          }
        case Array(major) =>
          if (major.toInt > latest(0)) {
            latest = Array(major.toInt, 0, 0)
          }
      }
    }
    latest
      .map(v => v.toString)
      .mkString(".")
  }
}

\end{lstlisting}

UpgradeCommand.scala
\begin{lstlisting}[style=AMMA, language=Scala]
import java.nio.file.{Files, Paths}

/**
 * Upgrade canary packages already installed. If the package is not found it will not be
 * automatically installed to prevent unintentional actions on behalf of the user
 *
 * @param packages  list of packages to upgrade
 * @param domain       canary remote repository
 * @param localPath local canary root
 */
case class UpgradeCommand(packages: List[String], domain: String, localPath: String) extends Command {
  override def run(): Unit = {
    val repo = new CanaryRepository(domain, localPath)
    for (name <- packages) {
      name.split('@') match {
        case Array(pkg, version) =>
          if (Files.exists(Paths.get(localPath, pkg)))
            repo.downloadPackage(pkg, version)
          else
            println(s"Package has not been installed. You can install it with 'canary install $name'")
        case Array(pkg) =>
          if (Files.exists(Paths.get(localPath, pkg)))
            repo.downloadPackage(pkg, "latest")
          else
            println(s"Package has not been installed. You can install it with 'canary install $name'")
      }
    }
  }
}

object UpgradeCommand {
  val usage: String =
    """
      |Usage: canary upgrade [OPTIONS] [PACKAGES...]
      |
      |Upgrades packages already installed
      |
      |Options:
      |    --repo URL for the repository to pull from
      |""".stripMargin
}

\end{lstlisting}

\newpage

\chapter{Canary Remote Repository}

The Canary repository is currently hosted at canary.wiles.fyi. This is a file server containing all canary packages,
which canary will pull from by default. Source code can be found at github.com/david-wiles/canary-remote.

Packages are stored in directories under the root as tar.gz files. These are named using the package name combined with
an underscore and the package version. The website also includes index.html files to make browsing easier for web browsers.

\begin{figure}[H]
    \caption{Canary repository file structure}
    \begin{center}
        \includegraphics[width=0.5\textwidth]{./fig/canary-remote-files.png}
    \end{center}
    \label{fig7}
\end{figure}

\newpage

\chapter{Docker Vagrantfile}

The Docker Vagrantfile creates a VM with Docker installed using the instructions from the Docker documentation.
This configuration is the basis for the Linux machines tested in this thesis.

\begin{lstlisting}[style=AMMA, language=ruby]
# -*- mode: ruby -*-
# vi: set ft=ruby :

$install = <<-'SCRIPT'
sudo apt-get update
sudo apt-get -y install \
    ca-certificates \
    curl \
    gnupg \
    lsb-release
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt-get update
sudo apt-get -y install docker-ce docker-ce-cli containerd.io

sudo apt update
sudo apt install nginx qemu-kvm libvirt-daemon-system
SCRIPT

Vagrant.configure("2") do |config|
  config.vm.box = "bento/ubuntu-20.04"
  config.vm.boot_timeout = 600 # My computer is slow
  config.vm.provision "shell", inline: $install
  config.vm.provider "virtualbox" do |vb|
    # Enable hardware virtualization on the vm
    vb.customize ["modifyvm", :id, "--nested-hw-virt", "on"]
  end
end

\end{lstlisting}
